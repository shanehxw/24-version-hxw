//-------------------------------------测距模块--------------------------------------------
                //-------测距预处理-------
                distance_midpoint_to_midpoint[0] = rect_centerpoint[0] - center_point[0];
                distance_midpoint_to_midpoint[1] = rect_centerpoint[1] - center_point[1];
                distance_midpoint_to_midpoint[2] = rect_centerpoint[2] - center_point[0];
                distance_midpoint_to_midpoint[3] = rect_centerpoint[3] - center_point[1];  // 计算中心点间的dx与dy

                for( i_temp = 0 ; i_temp < 4 ; i_temp++ )  // 计算绝对距离
                {
                    if(distance_midpoint_to_midpoint[i_temp] < 0)
                        distance_midpoint_to_midpoint[i_temp] = -distance_midpoint_to_midpoint[i_temp];
                }

                //-------记录第一帧信息，假设其在深度方向上水平-------
                if(frame_num == 1)  // 用于记录第一帧（假设深度为零）的中心点image距离
                    DISTANCE_DEEP_ZERO = ((std::hypot(distance_midpoint_to_midpoint[0],distance_midpoint_to_midpoint[1]))+(std::hypot(distance_midpoint_to_midpoint[2],distance_midpoint_to_midpoint[3])))/2;  
                
                //-------计算世界坐标系下的深度参数-------
                //deep_cal = (std::sqrt(std::pow(DISTANCE_DEEP_ZERO, 2) - (std::pow(distance_midpoint_to_midpoint[0], 2)+std::pow(distance_midpoint_to_midpoint[1],2))) + std::sqrt(std::pow(DISTANCE_DEEP_ZERO, 2) - (std::pow(distance_midpoint_to_midpoint[3], 2)+std::pow(distance_midpoint_to_midpoint[4],2)))) / 2;

                //-------构建世界坐标系与像素坐标系-------
                //world_point_array = { Point3d() , Point3d() , Point3d() , Point3d() , Point3d() , };
                //img_point_array = { Point2d() , Point2d() , Point2d() , Point2d() , Point2d() , };



                //cv::Point2f* img_example_2fpoint = new cv::Point2f(4);  
                //cv::Point3f* world_example_3fpoint = new cv::Point3f(4);
                // 注意free！！！
               
                //minAreaRects[i_memory].points(img_example_2fpoint);  // 2D点坐标
                
                //delete img_example_2fpoint;
                //delete world_example_3fpoint;
                // 如何知道哪个点对应世界坐标系上的对应点？
                //float world_example[12] = {0,0,0,0,20,}
                // 装甲板尺寸是多少？
---------------------------------------------------------------------------------------------------------
        //----------------------------------轮廓、中心点检测（主要模块1）-------------------------------------------
                
                std::vector<std::vector<cv::Point> > Point_fix;
                std::vector<cv::Vec4i> hierarchy;
                findContours(dst, Point_fix, hierarchy, cv::RETR_LIST, cv::CHAIN_APPROX_NONE);  // 检索外部轮廓，轮廓所有点储存

                //for (size_t i = 0; i < Point_fix.size(); i++) 
		            //cv::drawContours(frame, Point_fix, i, cv::Scalar(255, 255, 255), 1);  //暂时不可用

                //-------画出重要点-------
                std::vector<RotatedRect> minAreaRects(Point_fix.size());  // 用于储存矩形信息，成员center
                double center_x = 0;  
                double center_y = 0;  // 用于求中心点均值
                
                for (i_temp = 0 , j_temp = 0; i_temp < Point_fix.size(); i_temp++)  // 遍历所有轮廓
                {   
		            minAreaRects[i_temp] = minAreaRect(Point_fix[i_temp]);  // 获取轮廓的最小外接矩形
		            if(minAreaRects[i_temp].size.width * minAreaRects[i_temp].size.height >= 30)
                        {   
                        rect_centerpoint[j_temp] = minAreaRects[i_temp].center.x;
                        rect_centerpoint[j_temp+1] += minAreaRects[i_temp].center.y;  // 记录矩形中点的x，y坐标
                        j_temp += 2;
                        circle(frame, minAreaRects[i_temp].center, 10, Scalar(255, 0, 120), -1);
                        //std::cout<<"x = "<< minAreaRects[i].center.x << " y = " <<minAreaRects[i].center.y <<std::endl;
                        //std::cout<<"sum_x = "<<sum_x<<" sum_y = "<<sum_y<<std::endl;
                        }
                }
                
                //-------计算并画出中心点-------
                center_point[0] = double ((rect_centerpoint[0] + rect_centerpoint[2]) / 2);
                center_point[1] = double ((rect_centerpoint[1] + rect_centerpoint[3]) / 2);
                Point2d center_target(center_point[0], center_point[1]);
                circle(frame, center_target, 3, Scalar(255, 0, 255), -1);
                imshow("point",frame);

                //std::cout<<Point_fix.size()<<std::endl















                if(rect1_width >= rect1_height)  // 右板rect1右偏
                    {
                        img_input.push_back(rect_point1[0]);  // 1-1 右下
                        img_input.push_back(rect_point1[3]);  // 1-4 右上
                    }
                if(rect1_width < rect1_height)  // 右板rect1左偏
                    {
                        img_input.push_back(rect_point1[3]);  // 1-4 右下
                        img_input.push_back(rect_point1[2]);  // 1-3 右上
                    }

                if(rect2_width >= rect2_height)  // 左板rect2右偏
                    {
                        img_input.push_back(rect_point2[1]);  // 2-2 左下
                        img_input.push_back(rect_point2[2]);  // 2-3 左上
                    }
                if(rect2_width < rect2_height)  // 左板rect2左偏
                    {
                        img_input.push_back(rect_point2[0]);  // 2-1 左下
                        img_input.push_back(rect_point2[1]);  // 2-2 左上
                    }
                img_input.push_back(Point2f(center_point[0],center_point[1]));  // 中心




                Point2f temp = rect_point[0];
        for(int j = 1; j < point_num; j++){
            for(int i = 0; i < (point_num - j);)
            {
                if(rect_point[i].y <= rect_point[i+1].y)
                {   
                    temp = rect_point[i];
                    rect_point[i] = rect_point[i+1];
                }
            }
        }